{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedState = exports.getNextSortState = exports.getNextSortDirection = exports.initialSortState = exports.sortStates = void 0;\n\nvar _sorting = require(\"../tools/sorting\");\n/**\n * Copyright IBM Corp. 2016, 2018\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * We currently support the following sorting states for DataTable headers,\n * namely: `NONE` for no sorting being applied, and then `DESC` and `ASC` for\n * the corresponding direction of the sorting order.\n */\n\n\nvar sortStates = {\n  NONE: 'NONE',\n  DESC: 'DESC',\n  ASC: 'ASC'\n}; // Our initialSortState should be `NONE`, unless a consumer has specified a\n// different initialSortState\n\nexports.sortStates = sortStates;\nvar initialSortState = sortStates.NONE;\n/**\n * Utility used to get the next sort state given the following pieces of\n * information:\n *\n * @param {string} prevHeader the value of the previous header\n * @param {string} header the value of the currently selected header\n * @param {string} prevState the previous sort state of the table\n * @returns {string}\n */\n\nexports.initialSortState = initialSortState;\n\nvar getNextSortDirection = function getNextSortDirection(prevHeader, header, prevState) {\n  // If the previous header is equivalent to the current header, we know that we\n  // have to derive the next sort state from the previous sort state\n  if (prevHeader === header) {\n    // When transitioning, we know that the sequence of states is as follows:\n    // NONE -> ASC -> DESC -> NONE\n    if (prevState === 'NONE') {\n      return sortStates.ASC;\n    }\n\n    if (prevState === 'ASC') {\n      return sortStates.DESC;\n    }\n\n    return sortStates.NONE;\n  } // Otherwise, we have selected a new header and need to start off by sorting\n  // in descending order by default\n\n\n  return sortStates.ASC;\n};\n\nexports.getNextSortDirection = getNextSortDirection;\n\nvar getNextSortState = function getNextSortState(props, state, _ref) {\n  var key = _ref.key;\n  var sortDirection = state.sortDirection,\n      sortHeaderKey = state.sortHeaderKey;\n  var nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);\n  return getSortedState(props, state, key, nextSortDirection);\n};\n/**\n * Derive the set of sorted state fields from props and state for the given\n * header key and sortDirection\n *\n * @param {object} props\n * @param {string} props.locale The current locale\n * @param {Function} props.sortRows Method to handle sorting a collection of\n * rows\n * @param {object} state\n * @param {Array<string>} state.rowIds Array of row ids\n * @param {object} state.cellsById Lookup object for cells by id\n * @param {Array<string>} state.initialRowOrder Initial row order for the\n * current set of rows\n * @param {string} key The key for the given header we are derving the\n * sorted state for\n * @param {string} sortDirection The sortState that we want to order by\n * @returns {object}\n */\n\n\nexports.getNextSortState = getNextSortState;\n\nvar getSortedState = function getSortedState(props, state, key, sortDirection) {\n  var rowIds = state.rowIds,\n      cellsById = state.cellsById,\n      initialRowOrder = state.initialRowOrder;\n  var locale = props.locale,\n      sortRow = props.sortRow;\n  var nextRowIds = sortDirection !== sortStates.NONE ? (0, _sorting.sortRows)({\n    rowIds: rowIds,\n    cellsById: cellsById,\n    sortDirection: sortDirection,\n    key: key,\n    locale: locale,\n    sortRow: sortRow\n  }) : initialRowOrder;\n  return {\n    sortHeaderKey: key,\n    sortDirection: sortDirection,\n    rowIds: nextRowIds\n  };\n};\n\nexports.getSortedState = getSortedState;","map":{"version":3,"sources":["/Users/ggopinathpatro/Downloads/HMCReactive/carbon-react/carbon-react/node_modules/carbon-components-react/lib/components/DataTable/state/sorting.js"],"names":["Object","defineProperty","exports","value","getSortedState","getNextSortState","getNextSortDirection","initialSortState","sortStates","_sorting","require","NONE","DESC","ASC","prevHeader","header","prevState","props","state","_ref","key","sortDirection","sortHeaderKey","nextSortDirection","rowIds","cellsById","initialRowOrder","locale","sortRow","nextRowIds","sortRows"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedState = exports.getNextSortState = exports.getNextSortDirection = exports.initialSortState = exports.sortStates = void 0;\n\nvar _sorting = require(\"../tools/sorting\");\n\n/**\n * Copyright IBM Corp. 2016, 2018\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * We currently support the following sorting states for DataTable headers,\n * namely: `NONE` for no sorting being applied, and then `DESC` and `ASC` for\n * the corresponding direction of the sorting order.\n */\nvar sortStates = {\n  NONE: 'NONE',\n  DESC: 'DESC',\n  ASC: 'ASC'\n}; // Our initialSortState should be `NONE`, unless a consumer has specified a\n// different initialSortState\n\nexports.sortStates = sortStates;\nvar initialSortState = sortStates.NONE;\n/**\n * Utility used to get the next sort state given the following pieces of\n * information:\n *\n * @param {string} prevHeader the value of the previous header\n * @param {string} header the value of the currently selected header\n * @param {string} prevState the previous sort state of the table\n * @returns {string}\n */\n\nexports.initialSortState = initialSortState;\n\nvar getNextSortDirection = function getNextSortDirection(prevHeader, header, prevState) {\n  // If the previous header is equivalent to the current header, we know that we\n  // have to derive the next sort state from the previous sort state\n  if (prevHeader === header) {\n    // When transitioning, we know that the sequence of states is as follows:\n    // NONE -> ASC -> DESC -> NONE\n    if (prevState === 'NONE') {\n      return sortStates.ASC;\n    }\n\n    if (prevState === 'ASC') {\n      return sortStates.DESC;\n    }\n\n    return sortStates.NONE;\n  } // Otherwise, we have selected a new header and need to start off by sorting\n  // in descending order by default\n\n\n  return sortStates.ASC;\n};\n\nexports.getNextSortDirection = getNextSortDirection;\n\nvar getNextSortState = function getNextSortState(props, state, _ref) {\n  var key = _ref.key;\n  var sortDirection = state.sortDirection,\n      sortHeaderKey = state.sortHeaderKey;\n  var nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);\n  return getSortedState(props, state, key, nextSortDirection);\n};\n/**\n * Derive the set of sorted state fields from props and state for the given\n * header key and sortDirection\n *\n * @param {object} props\n * @param {string} props.locale The current locale\n * @param {Function} props.sortRows Method to handle sorting a collection of\n * rows\n * @param {object} state\n * @param {Array<string>} state.rowIds Array of row ids\n * @param {object} state.cellsById Lookup object for cells by id\n * @param {Array<string>} state.initialRowOrder Initial row order for the\n * current set of rows\n * @param {string} key The key for the given header we are derving the\n * sorted state for\n * @param {string} sortDirection The sortState that we want to order by\n * @returns {object}\n */\n\n\nexports.getNextSortState = getNextSortState;\n\nvar getSortedState = function getSortedState(props, state, key, sortDirection) {\n  var rowIds = state.rowIds,\n      cellsById = state.cellsById,\n      initialRowOrder = state.initialRowOrder;\n  var locale = props.locale,\n      sortRow = props.sortRow;\n  var nextRowIds = sortDirection !== sortStates.NONE ? (0, _sorting.sortRows)({\n    rowIds: rowIds,\n    cellsById: cellsById,\n    sortDirection: sortDirection,\n    key: key,\n    locale: locale,\n    sortRow: sortRow\n  }) : initialRowOrder;\n  return {\n    sortHeaderKey: key,\n    sortDirection: sortDirection,\n    rowIds: nextRowIds\n  };\n};\n\nexports.getSortedState = getSortedState;"]},"metadata":{},"sourceType":"script"}